#!/usr/bin/env python3

"""
Git Fresh is script that will automatically do a few things to get back
to a fresh state.

Actions:
1. Clean the working directory.
2. Checkout to the default branch.
3. Pull the latest changes with pruning.
4. Delete any local branches deleted on remote.
"""

import subprocess
import re
import argparse


def _run(cmd: str):
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
    return result


def is_deleted_in_remote(branch: str) -> bool:
    deleted_pattern = re.compile(r": gone\]")
    matched = deleted_pattern.search(branch)
    return matched is not None


def handle_deleted_branches(branches: list[str], dry_run: bool) -> None:
    deleted_branches = list(filter(is_deleted_in_remote, branches))
    # deleted_branches = branches
    for branch in deleted_branches:
        branch_name = branch.split()[0]
        if branch_name == "*":
            # Somehow is our current branch, the star represents the
            # branch we are on. Continue on to next branch instead
            continue
        print(f"Deleting branch: '{branch_name}'")
        if dry_run:
            print("Running in dry-run mode. Branch was not really deleted")
        else:
            _run(f"git branch -D {branch_name}")


def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not delete anything, just do a dry run.",
    )
    args = argparser.parse_args()
    _run("git clean -fxd")
    _run("git switch main")
    _run("git pull")
    branch_result = _run("git branch -vv")
    branches = branch_result.stdout.splitlines()
    handle_deleted_branches(branches, args.dry_run)


if __name__ == "__main__":
    main()
